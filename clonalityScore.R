#!/usr/bin/env Rscript

suppressMessages({
  library(ggplot2)
  library(cowplot)
  library(ggbeeswarm)
  library(data.table)
  library(GenomicRanges)
  library(breakclone) ##https://github.com/Sawyer-s-Group/breakclone
  library(QDNAseq)
  library(parallel)
})

##My functions

#' Read in copy number tsv files
#'
#' Read in copy number data from CNACalling.R results and return it in the format that breakclone uses for VCF files.
#' @param directory A directory containing the files.
#' @param pattern The filename pattern matching the files.
#' @param dupThreshold log2rate threshold to consider a segment as a gain.
#' @param delThreshold log2rate threshold to consider a segment as a loss.
#' @param discardAsPloidy discard segments with rounded absolute copy number == rounded ploidy
#' @return A data.table with column names SampleID, Chr, Start, End, Bins, SVType, Length.
#' @export
readTsvN <- function(directory, pattern = "^(.*)[:.:]([^.]*)[:.:]best[:.:]ACNAs[:.:]c(.*)[:.:]p(.*)[:.:]tsv$",dupThreshold=0,delThreshold=0,discardAsPloidy=T){
  fileList <- dir(directory, pattern, full.names = TRUE)
  segmentTable <- rbindlist(lapply(fileList, function(file){
    thedata=fread(file)
    thedata[,`:=`(patient=gsub(basename(file),pattern=pattern,replacement="\\1"),
                  sample=gsub(basename(file),pattern=pattern,replacement="\\2"),
                  cellularity=as.numeric(gsub(basename(file),pattern=pattern,replacement="\\3")),
                  ploidy=as.numeric(gsub(basename(file),pattern=pattern,replacement="\\4")))]
    return(thedata)
    }))
  segmentTable[,`:=`(SVType=ifelse(absolute_copy_number>ploidy,"DUP","DEL"),
                     Length=end-start+1,
                     fullLabel=paste(sep=".",patient,sample),
                     chromosome=as.character(chromosome))]
  
  if(discardAsPloidy==T){
    segmentTable <- segmentTable[round(absolute_copy_number)!=round(ploidy),]
  }
  segmentTable <- segmentTable[log2_ratio>dupThreshold | log2_ratio<delThreshold,]
  setnames(segmentTable,old=c("chromosome","start","end","bins","sample"),new=c("Chr", "Start", "End", "Bins", "label"))
  return(segmentTable[,.(patient, label, fullLabel, Chr, Start, End, Bins, SVType, Length)])
}

#' Generate reference distribution from copy number data using pre-calculated pairs of samples from different individuals
#' This function uses parallel to speed up the calculations
#' @param segmentTable A segment table generated by the readAlleleSpecific, readVCFCn or readSegN functions.
#' @param refPairs A data.table with all reference pairs (i.e., all comparisons of samples from different patients) from the dataset.
#' @param cnType The type of copy number data provided. Currently supported options are a custom allele specific data format, and standard copy number VCF files.
#' @param excludeChromosomes The name(s) of any chromosomes to be excluded.
#' @param maxgap The maximum gap between two breakpoints for them to be considered concordant. If unspecified, it is automatically set to 5 times the average interprobe distance of the assay.
#' @return A numeric vector of pair scores comprising the reference distribution.
makeReferenceCNPrecalculatedNullPairs <- function(segmentTable, refPairs, cnType = c("alleleSpecific", "VCF"), excludeChromosomes = "Y", maxgap = NULL){
  require(parallel)
  message("Making reference based on ", nrow(refPairs), " possible pairs, this might take a while")
  
  cnType <- match.arg(cnType)
  segmentTable <- segmentTable[!excludeChromosomes, on = "Chr"]
  populationBreakpoints <- breakclone:::collatePopulationBreakpoints(segmentTable, cnType)
  if(is.null(maxgap)){maxgap <- breakclone:::calculateMaxGap(segmentTable, cnType)}
  reference <- simplify2array(mclapply(asplit(refPairs, 1), function(x){breakclone:::getScoreCN(segmentTable,x, populationBreakpoints, cnType, maxgap)}))
  return(reference)
}

#' Calculate relatedness scores for paired tumors in parallel
#'
#' Calculates the relatedness scores and (optionally) p-values for paired tumours from copy number data
#' @param segmentTable A segment table generated by the readAlleleSpecific or readVCFCn functions.
#' @param pairs A table of paired samples from the dataset, to test for relatedness.
#' @param reference A numeric vector of pair scores comprising the reference distribution, generated from the \code{makeReferenceCN} function. If omitted, p-value calculation will be skipped.
#' @param cnType The type of copy number data provided. Currently supported options are a custom allele specific data format, and standard copy number VCF files.
#' @param excludeChromosomes The name(s) of any chromosomes to be excluded.
#' @param maxgap The maximum gap between two breakpoints for them to be considered concordant. If unspecified, it is automatically set to 5 times the average interprobe distance of the assay.
#' @return A data frame listing the tumour pairs contained in \code{pairs}, their relatedness scores and p-values for relatedness.
calculateRelatednessCnParallel <- function(segmentTable, pairs, reference = NULL, cnType = c("alleleSpecific", "VCF"), excludeChromosomes = "Y", maxgap = NULL){
  require(parallel)
  cnType <- match.arg(cnType)
  segmentTable <- segmentTable[!excludeChromosomes, on = "Chr"]
  populationBreakpoints <- breakclone:::collatePopulationBreakpoints(segmentTable, cnType)
  if(is.null(maxgap)){maxgap <- breakclone:::calculateMaxGap(segmentTable, cnType)}
  
  pair_scores <- simplify2array(mclapply(asplit(pairs, 1), function(x){breakclone:::getScoreCN(segmentTable, as.character(x), populationBreakpoints, cnType, maxgap)}))
  
  if(is.null(reference)){warning("No reference supplied, p-values not calculated", immediate. = TRUE)}
  pair_ps <- simplify2array(mclapply(pair_scores, function(x){
    n <- length(x)
    ne <- sum(x >= reference)
    return((n-ne+1)/(n+1))}))
  results <- cbind.data.frame(pairs, pair_scores, pair_ps)
  
  return(results)
}

#' This adds stage information from information stored in sampleData to a pairs object
addStageInformation = function (x) {
  setkey(x,Sample1)
  x[,`:=`(Stage1=sampleData[x,Stage])]
  setkey(x,Sample2)
  x[,`:=`(Stage2=sampleData[x,Stage])]
}

#' This adds stage information from information stored in sampleData to a pairs object
addPatientInformation = function (x) {
  setkey(x,Sample1)
  x[,`:=`(Patient1=sampleData[x,patient])]
  setkey(x,Sample2)
  x[,`:=`(Patient2=sampleData[x,patient])]
}

#' Annotation function to use in with stat_summary(geom="text") to add a median label
#' Parameters must be pased in a list in fun.params and the function as fun.data
#' @param label content before the number
#' @param ndigits number of decimals for rounding
#' @param yjust absolute amount to add to the y position of the label. For the other use vjust in stat_summary
#' @param pyjust multiplicative modification of the y position of the label
myMedianAnnotation=function(x,label="Ã±:",ndigits=1,yjust=0,pyjust=1){
  return(data.frame(y=pyjust*median(x)+yjust,label=paste0(label,round(median(x),digits = ndigits))))
}

##Config
configFile <- paste(sep="/",Sys.getenv("lviProjectDNAScripts"),"configFile")
if(!file.exists(configFile)){
    stop("Configuration file configFile not found. Edit configFile.in to adapt it to your system, save it as configFile, and export the lviProjectDNAScripts environment variable before running this script")
}
source(configFile)
setDTthreads(1)
inputDir <- acnaDir
varFile <- paste(sep="/",acnaDir,"variance.tsv")

inputDataImage <- paste(sep="/",inputDir,inputDataImageName) #Not needed
calculationDataImage <- paste(sep="/",inputDir,calculationDataImageName) #Not needed

options(mc.cores=mc_cores)

##Data parsing##
################
if(file.exists(calculationDataImage)){
  load(calculationDataImage)
} else {
  if(file.exists(inputDataImage)){
    load(inputDataImage)
  } else {
    sampleData <- fread(sampleDataFile)
    unfilteredSegments <- readTsvN(directory = inputDir)
    filteredSegments <- readTsvN(directory = inputDir,dupThreshold=0.3,delThreshold=-0.3)
    setkey(sampleData,fullLabel)
    setkey(unfilteredSegments,fullLabel)
    setkey(filteredSegments,fullLabel)
    save.image(inputDataImage)
  } 
  #Adding stage information to the results since I will end up filtering using that
  filteredSegments <- merge(filteredSegments,sampleData[,.(fullLabel,Stage)],by="fullLabel")
  unfilteredSegments <- merge(unfilteredSegments,sampleData[,.(fullLabel,Stage)],by="fullLabel")
  
  #Removing samples from which we don't have data
  sampleData <- sampleData[unfilteredSegments[,.N,by=fullLabel]]
  
  ##Making pairs of samples for comparisons and null distribution##
  #################################################################
  pairs=sapply(X=sampleData[,unique(patient)],FUN = function(x){t(combn(sampleData[patient==x,fullLabel],2))})
  pairsPerPatient=lapply(pairs,function(x){out=data.table(x);setnames(out,old=c("V1","V2"),new=c("Sample1","Sample2"));return(out)})
  pairs=rbindlist(pairsPerPatient)
  
  #Adding stage and patient information to the pairs since I will end up filtering using them
  addStageInformation(pairs)
  addPatientInformation(pairs)
  pairs[,Patient2:=NULL]
  setnames(pairs,old="Patient1",new="Patient")
  
  #Make all pairs of samples from different patients
  allPairs=data.table(t(combn(sampleData[,fullLabel],2)))
  setnames(allPairs,old=c("V1","V2"),new=c("Sample1","Sample2"))
  
  #Adding stage information to the pairs since I will end up filtering using that
  addPatientInformation(allPairs)
  addStageInformation(allPairs)
  
  ##Filtering results by stage
  finalFilteredSegments=filteredSegments[Stage != "NORMAL",`:=`(SampleID=fullLabel)]
  finalUnfilteredSegments=unfilteredSegments[Stage != "NORMAL",`:=`(SampleID=fullLabel)]
  finalNullPairs=allPairs[(Patient1 != Patient2) & Stage1 != "NORMAL" & Stage2 != "NORMAL"]
  finalPairs=pairs[Stage1 != "NORMAL" & Stage2 != "NORMAL"]
  
  #Get null distribution of clonality score
  nullEmpiricalDistributionFiltered=makeReferenceCNPrecalculatedNullPairs(finalFilteredSegments,finalNullPairs[,.(Sample1,Sample2)],"VCF")
  nullEmpiricalDistributionDataFiltered=data.table(score=nullEmpiricalDistributionFiltered)
  
  #Get sample distribution of clonality scores within patients
  resultsFiltered=calculateRelatednessCnParallel(segmentTable = finalFilteredSegments,pairs = finalPairs,reference = nullEmpiricalDistributionFiltered, cnType = "VCF")
  setDT(resultsFiltered)
  
  #Get null distribution of clonality score
  nullEmpiricalDistributionUnfiltered=makeReferenceCNPrecalculatedNullPairs(finalUnfilteredSegments,finalNullPairs,"VCF")
  nullEmpiricalDistributionDataUnfiltered=data.table(score=nullEmpiricalDistributionUnfiltered)
  
  #Get sample distribution of clonality scores within patients
  resultsUnfiltered=calculateRelatednessCnParallel(segmentTable = finalUnfilteredSegments,pairs = finalPairs,reference = nullEmpiricalDistributionUnfiltered, cnType = "VCF")
  setDT(resultsUnfiltered)
  
  #Merging final null distributions
  finalNullEmpiricalDistributions=copy(finalNullPairs)
  finalNullEmpiricalDistributions[,`:=`(filteredScore=nullEmpiricalDistributionDataFiltered$score,unfilteredScore=nullEmpiricalDistributionDataUnfiltered$score)]
  
  #Some additional data modification
  resultsUnfiltered[,`:=`(isSameStage=Stage1 == Stage2)]
  resultsFiltered[,`:=`(isSameStage=Stage1 == Stage2)]
  
  #Thresholds
  filteredThreshold=quantile(finalNullEmpiricalDistributions[,filteredScore],probs=0.95)
  unfilteredThreshold=quantile(finalNullEmpiricalDistributions[,unfilteredScore],probs=0.95)
  save.image(calculationDataImage)
}

##Taking a look at null empirical distributions
#ggplot(data=finalNullEmpiricalDistributions[,.(unfilteredScore,isSame=Stage1 == Stage2)],aes(x=unfilteredScore,fill=isSame))+geom_density(alpha=0.5)+theme_cowplot()
#ggplot(data=finalNullEmpiricalDistributions[,.(filteredScore,isSame=Stage1 == Stage2)],aes(x=filteredScore,fill=isSame))+geom_density(alpha=0.5)+theme_cowplot()
#ggplot(data=rbind(nullEmpiricalDistributionDataFiltered[,.(score,type="between")],resultsFiltered[,.(score=pair_scores,type="within")]),aes(x=score,fill=type))+geom_density(alpha=0.5)+theme_cowplot()
#ggplot(data=rbind(nullEmpiricalDistributionDataUnfiltered[,.(score,type="between")],resultsUnfiltered[,.(score=pair_scores,type="within")]),aes(x=score,fill=type))+geom_density(alpha=0.5)+theme_cowplot()

#Is LVI clonal with DCIS and/or IBC?
##Is at least one LVI per patient clonal with a DCIS sample?
##For DCIS, one case is not, the rest are, for IBC, all are. 
resultsUnfiltered[order(pair_ps),][(Stage1=="DCIS" & Stage2=="LVI"),lapply(.SD,first),by=Patient][,`:=`(adjusted.p=p.adjust(pair_ps,method="fdr"))][,sum(adjusted.p>=0.05)]
resultsUnfiltered[order(pair_ps),][(Stage1=="IBC" & Stage2=="LVI"),lapply(.SD,first),by=Patient][,`:=`(adjusted.p=p.adjust(pair_ps,method="fdr"))][,sum(adjusted.p>=0.05)]

##Random DCIS/IBC pairings per patient and calculate the mean proportion of samples that are not clearly clonal
mean(sapply(1:1000,function(x){
  resultsUnfiltered[sample(.N),][(Stage1=="DCIS" & Stage2=="LVI"),lapply(.SD,first),by=Patient][,`:=`(adjusted.p=p.adjust(pair_ps,method="fdr"))][order(adjusted.p),][,mean(adjusted.p>=0.05)]
}))
mean(sapply(1:1000,function(x){
  resultsUnfiltered[sample(.N),][(Stage1=="IBC" & Stage2=="LVI"),lapply(.SD,first),by=Patient][,`:=`(adjusted.p=p.adjust(pair_ps,method="fdr"))][order(adjusted.p),][,mean(adjusted.p>=0.05)]
}))

##We can also pick the least noisy sample per type
varData <- fread(varFile)
sampleData <- merge(sampleData,varData,by=c("patient","label"))
theseSamples <- sampleData[order(observedVariance),lapply(.SD,first),by=.(patient,Stage)][,.SD,keyby=.(fullLabel)] #Using variance

resultsUnfiltered[Sample1 %in% theseSamples$fullLabel & Sample2 %in% theseSamples$fullLabel,][(Stage1=="DCIS" & Stage2=="LVI"),][,`:=`(adjusted.p=p.adjust(pair_ps,method="fdr"))][order(adjusted.p),][,mean(adjusted.p>=0.05)]
resultsUnfiltered[Sample1 %in% theseSamples$fullLabel & Sample2 %in% theseSamples$fullLabel,][(Stage1=="IBC" & Stage2=="LVI"),][,`:=`(adjusted.p=p.adjust(pair_ps,method="fdr"))][order(adjusted.p),][,mean(adjusted.p>=0.05)]
